package pulse;

import pulse.network.Buffer;
import pulse.network.BuiltinType;
import pulse.network.Type;

import java.io.IOException;
import java.lang.classfile.*;
import java.lang.classfile.attribute.SignatureAttribute;
import java.lang.classfile.attribute.SourceFileAttribute;
import java.lang.classfile.instruction.SwitchCase;
import java.lang.constant.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.function.BiConsumer;
import java.util.function.Supplier;

import static java.util.Map.entry;

// TODO: refactor
public final class CodeGen {
    public static final String GENERATED_CLIENT_SUFFIX = "PulseGeneratedClient";
    public static final String GENERATED_SERVER_SUFFIX = "PulseGeneratedServer";

    record SerializerField(String name, Class<?> targetType) {
    }

    static <T> byte[] implementClient(Class<T> proto, int id) throws Throwable {
        var generatedClassDesc = ClassDesc.of(proto.getName() + '$' + GENERATED_CLIENT_SUFFIX);

        var classBytes = ClassFile.of().build(generatedClassDesc, classBuilder -> {
            classBuilder
                    .with(SourceFileAttribute.of(classBuilder.constantPool().utf8Entry(("Generated by Pulse"))))
                    .withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_FINAL)
                    .withInterfaceSymbols(ClassDesc.of(proto.getName()));

            var pulseClientClassDesc = ClassDesc.of(PulseClient.class.getName());
            classBuilder.withField("client", pulseClientClassDesc,
                    fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL));

            DirectMethodHandleDesc bootstrapMethodDesc = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,
                    ClassDesc.of("java.lang.invoke.LambdaMetafactory"),
                    "metafactory",
                    MethodTypeDesc.ofDescriptor("(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;"
                            + "Ljava/lang/invoke/MethodType;"
                            + "Ljava/lang/invoke/MethodType;"
                            + "Ljava/lang/invoke/MethodHandle;"
                            + "Ljava/lang/invoke/MethodType;"
                            + ")Ljava/lang/invoke/CallSite;"));

            var bufferClassDesc = ClassDesc.of(Buffer.class.getName());
            var bufferWritableClassDesc = ClassDesc.of(Buffer.Writable.class.getName());
            var bufferWriteSelfIntoMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, bufferClassDesc);

            var bufferReadByteMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_byte);
            var bufferWriteByteMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_byte);
            var bufferReadBooleanMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_boolean);
            var bufferWriteBooleanMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_boolean);
            var bufferReadCharMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_char);
            var bufferWriteCharMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_char);
            var bufferReadShortMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_short);
            var bufferWriteShortMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_short);
            var bufferReadIntMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_int);
            var bufferWriteIntMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_int);
            var bufferReadLongMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_long);
            var bufferWriteLongMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_long);
            var bufferReadFloatMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_float);
            var bufferWriteFloatMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_float);
            var bufferReadDoubleMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_double);
            var bufferWriteDoubleMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_double);

            var futureClassDesc = ClassDesc.of(Future.class.getName());
            var clientCallMethodDesc = MethodTypeDesc.of(futureClassDesc, bufferWritableClassDesc);

            var mapClassDesc = ClassDesc.of(Map.class.getName());
            var mapGetMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_Object, ConstantDescs.CD_Object);

            var networkTypeClassDesc = ClassDesc.of(Type.class.getName());
            var networkTypeClassDescStr = networkTypeClassDesc.descriptorString();
            var networkTypeClassDescStrForSignature = networkTypeClassDescStr.substring(0, networkTypeClassDescStr.length() - 1);
            var networkTypeReadMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_Object, bufferClassDesc);
            var networkTypeWriteMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, bufferClassDesc, ConstantDescs.CD_Object);

            var illegalArgExDesc = ClassDesc.of(IllegalArgumentException.class.getName());
            var illegalArgExConstructorDesc = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String);

            var nextFieldId = 0;
            var classDescToSerializerFieldMap = new LinkedHashMap<ClassDesc, SerializerField>();

            var noArgConstructorDesc = MethodTypeDesc.of(ConstantDescs.CD_void);

            Map<Class<?>, Class<?>> builtinTypeSerializers = Map.ofEntries(
                    entry(Byte.class, BuiltinType.ByteType.class),
                    entry(byte[].class, BuiltinType.ByteArrayType.class),
                    entry(Boolean.class, BuiltinType.BooleanType.class),
                    entry(boolean[].class, BuiltinType.BooleanArrayType.class),
                    entry(Character.class, BuiltinType.CharacterType.class),
                    entry(char[].class, BuiltinType.CharArrayType.class),
                    entry(Short.class, BuiltinType.ShortType.class),
                    entry(short[].class, BuiltinType.ShortArrayType.class),
                    entry(Integer.class, BuiltinType.IntegerType.class),
                    entry(int[].class, BuiltinType.IntArrayType.class),
                    entry(Long.class, BuiltinType.LongType.class),
                    entry(long[].class, BuiltinType.LongArrayType.class),
                    entry(Float.class, BuiltinType.FloatType.class),
                    entry(float[].class, BuiltinType.FloatArrayType.class),
                    entry(Double.class, BuiltinType.DoubleType.class),
                    entry(double[].class, BuiltinType.DoubleArrayType.class),
                    entry(String.class, BuiltinType.StringUtf8Type.class)
            );

            Method[] declaredMethods = proto.getDeclaredMethods();
            Arrays.sort(declaredMethods, Comparator.comparing(Method::getName));

            for (int i = 0; i < declaredMethods.length; i++) {
                var declaredMethod = declaredMethods[i];

                int declaredModifiers = declaredMethod.getModifiers();
                if (Modifier.isFinal(declaredModifiers) || Modifier.isStatic(declaredModifiers)) continue;

                var returnType = declaredMethod.getReturnType();
                var returnTypeDescStr = returnType.descriptorString();
                var returnTypeClassDesc = ClassDesc.ofDescriptor(returnTypeDescStr);

                if (!returnTypeClassDesc.isPrimitive()) {
                    var typeName = returnTypeClassDesc.displayName().replace("[]", "Array");
                    var fieldName = typeName + '$' + "ser" + nextFieldId++;
                    classDescToSerializerFieldMap.computeIfAbsent(returnTypeClassDesc, _ -> {
                        var signature = SignatureAttribute.of(Signature.parseFrom(
                                String.format("%s<%s>;", networkTypeClassDescStrForSignature, returnTypeDescStr)
                        ));
                        classBuilder.withField(fieldName, networkTypeClassDesc,
                                fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL).with(signature));
                        return new SerializerField(fieldName, returnType);
                    });
                }

                var parametersClassDescs = new ArrayList<ClassDesc>();
                for (Parameter parameter : declaredMethod.getParameters()) {
                    var parameterType = parameter.getType();
                    var parameterClassDesc = ClassDesc.ofDescriptor(parameterType.descriptorString());
                    parametersClassDescs.add(parameterClassDesc);

                    if (!parameterClassDesc.isPrimitive()) {
                        var typeName = parameterClassDesc.displayName().replace("[]", "Array");
                        var fieldName = typeName + '$' + "ser" + nextFieldId++;
                        classDescToSerializerFieldMap.computeIfAbsent(parameterClassDesc, _ -> {
                            var signature = SignatureAttribute.of(Signature.parseFrom(
                                    String.format("%s<%s>;", networkTypeClassDescStrForSignature, parameterClassDesc.descriptorString())
                            ));
                            classBuilder.withField(fieldName, networkTypeClassDesc,
                                    fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL).with(signature));
                            return new SerializerField(fieldName, parameterType);
                        });
                    }
                }

                var lambdaName = "lambda" + '$' + declaredMethod.getName() + '$' + i;
                var lambdaParametersClassDescs = new ArrayList<>(parametersClassDescs);
                lambdaParametersClassDescs.addFirst(generatedClassDesc);
                lambdaParametersClassDescs.add(bufferClassDesc);
                var lambdaClassDesc = MethodTypeDesc.of(ConstantDescs.CD_void, lambdaParametersClassDescs);

                int methodId = i;
                classBuilder.withMethodBody(lambdaName, lambdaClassDesc,
                        ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, codeBuilder -> {
                            int bufSlot = 1; // 0 = this
                            for (var parameterDesc : parametersClassDescs) {
                                var descStr = parameterDesc.descriptorString();
                                if ("J".equals(descStr) || "D".equals(descStr)) {
                                    bufSlot += 2;
                                } else {
                                    bufSlot += 1;
                                }
                            }

                            codeBuilder
                                    .aload(bufSlot)
                                    .loadConstant(id)
                                    .invokevirtual(bufferClassDesc, "writeVarInt", bufferWriteIntMethodDesc);
                            codeBuilder
                                    .aload(bufSlot)
                                    .loadConstant(methodId)
                                    .invokevirtual(bufferClassDesc, "writeVarInt", bufferWriteIntMethodDesc);

                            int slot = 1; // 0 = this
                            for (var parametersClassDesc : parametersClassDescs) {
                                var parameterDescStr = parametersClassDesc.descriptorString();

                                switch (parameterDescStr) {
                                    case "B" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .iload(slot)
                                                .invokevirtual(bufferClassDesc, "writeByte", bufferWriteByteMethodDesc);
                                        slot += 1;
                                    }
                                    case "Z" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .iload(slot)
                                                .invokevirtual(bufferClassDesc, "writeBoolean", bufferWriteBooleanMethodDesc);
                                        slot += 1;
                                    }
                                    case "C" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .iload(slot)
                                                .invokevirtual(bufferClassDesc, "writeChar", bufferWriteCharMethodDesc);
                                        slot += 1;
                                    }
                                    case "S" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .iload(slot)
                                                .invokevirtual(bufferClassDesc, "writeShort", bufferWriteShortMethodDesc);
                                        slot += 1;
                                    }

                                    case "I" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .iload(slot)
                                                .invokevirtual(bufferClassDesc, "writeInt", bufferWriteIntMethodDesc);
                                        slot += 1;
                                    }
                                    case "F" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .fload(slot)
                                                .invokevirtual(bufferClassDesc, "writeFloat", bufferWriteFloatMethodDesc);
                                        slot += 1;
                                    }

                                    case "J" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .lload(slot)
                                                .invokevirtual(bufferClassDesc, "writeLong", bufferWriteLongMethodDesc);
                                        slot += 2;
                                    }
                                    case "D" -> {
                                        codeBuilder
                                                .aload(bufSlot)
                                                .dload(slot)
                                                .invokevirtual(bufferClassDesc, "writeDouble", bufferWriteDoubleMethodDesc);
                                        slot += 2;
                                    }

                                    default -> {
                                        var serializerField = classDescToSerializerFieldMap.get(parametersClassDesc);
                                        assert serializerField != null;

                                        codeBuilder
                                                .aload(0)
                                                .getfield(generatedClassDesc, serializerField.name, networkTypeClassDesc)
                                                .aload(bufSlot)
                                                .aload(slot)
                                                .invokeinterface(networkTypeClassDesc, "write", networkTypeWriteMethodDesc);
                                        slot += 1;
                                    }
                                }
                            }

                            codeBuilder.return_();
                        });

                var declaredMethodDesc = MethodTypeDesc.of(returnTypeClassDesc, parametersClassDescs);
                int newModifiers = (declaredMethod.getModifiers() & ~Modifier.ABSTRACT) | Modifier.PUBLIC;

                classBuilder.withMethodBody(declaredMethod.getName(), declaredMethodDesc, newModifiers, codeBuilder -> {
                    var invocationParams = new ArrayList<>(parametersClassDescs);

                    invocationParams.addFirst(generatedClassDesc);
                    var invocationType = MethodTypeDesc.of(bufferWritableClassDesc, invocationParams);

                    invocationParams.addLast(bufferClassDesc);
                    var lookupMethodType = MethodTypeDesc.of(ConstantDescs.CD_void, invocationParams);

                    var callSiteDesc = DynamicCallSiteDesc.of(
                            bootstrapMethodDesc,
                            "writeSelfInto",
                            invocationType,
                            bufferWriteSelfIntoMethodDesc,
                            MethodHandleDesc.ofMethod(
                                    DirectMethodHandleDesc.Kind.STATIC,
                                    generatedClassDesc,
                                    lambdaName,
                                    lookupMethodType
                            ),
                            bufferWriteSelfIntoMethodDesc
                    );

                    codeBuilder.aload(0);

                    int slot = 1; // 0 = this
                    for (var parameterClassDesc : parametersClassDescs) {
                        switch (parameterClassDesc.descriptorString()) {
                            case "I", "B", "S", "C", "Z" -> {
                                codeBuilder.iload(slot);
                                slot += 1;
                            }
                            case "F" -> {
                                codeBuilder.fload(slot);
                                slot += 1;
                            }

                            case "J" -> {
                                codeBuilder.lload(slot);
                                slot += 2;
                            }
                            case "D" -> {
                                codeBuilder.dload(slot);
                                slot += 2;
                            }

                            default -> {
                                codeBuilder.aload(slot);
                                slot += 1;
                            }
                        }
                    }

                    codeBuilder
                            .invokedynamic(callSiteDesc)
                            .astore(3);

                    codeBuilder
                            .aload(0)
                            .getfield(generatedClassDesc, "client", pulseClientClassDesc)
                            .aload(3);

                    codeBuilder
                            .invokevirtual(pulseClientClassDesc, "call", clientCallMethodDesc)
                            .invokeinterface(futureClassDesc, "get", MethodTypeDesc.of(ConstantDescs.CD_Object));

                    switch (returnTypeDescStr) {
                        case "B" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .invokevirtual(bufferClassDesc, "readByte", bufferReadByteMethodDesc)
                                .ireturn();
                        case "Z" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readBoolean", bufferReadBooleanMethodDesc)
                                .ireturn();
                        case "C" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readChar", bufferReadCharMethodDesc)
                                .ireturn();
                        case "S" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readShort", bufferReadShortMethodDesc)
                                .ireturn();
                        case "I" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readInt", bufferReadIntMethodDesc)
                                .ireturn();
                        case "F" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readFloat", bufferReadFloatMethodDesc)
                                .freturn();

                        case "J" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readLong", bufferReadLongMethodDesc)
                                .lreturn();
                        case "D" -> codeBuilder
                                .checkcast(bufferClassDesc)
                                .astore(4)
                                .aload(4)
                                .invokevirtual(bufferClassDesc, "readDouble", bufferReadDoubleMethodDesc)
                                .dreturn();

                        case "V" -> codeBuilder.return_();

                        default -> {
                            var serializerField = classDescToSerializerFieldMap.get(returnTypeClassDesc);
                            assert serializerField != null;

                            codeBuilder
                                    .checkcast(bufferClassDesc)
                                    .astore(4)
                                    .aload(0)
                                    .getfield(generatedClassDesc, serializerField.name, networkTypeClassDesc)
                                    .aload(4)
                                    .invokeinterface(networkTypeClassDesc, "read", networkTypeReadMethodDesc)
                                    .checkcast(returnTypeClassDesc)
                                    .areturn();
                        }
                    }
                });
            }

            var constructorMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, pulseClientClassDesc, mapClassDesc);
            classBuilder.withMethodBody("<init>", constructorMethodDesc, ClassFile.ACC_PUBLIC, codeBuilder -> {
                codeBuilder
                        .aload(0)
                        .invokespecial(ConstantDescs.CD_Object, "<init>", noArgConstructorDesc)
                        .aload(0)
                        .aload(1)
                        .putfield(generatedClassDesc, "client", pulseClientClassDesc);

                for (var entry : classDescToSerializerFieldMap.entrySet()) {
                    var typeDesc = entry.getKey();
                    var serializerField = entry.getValue();

                    var valueIsNotNull = codeBuilder.newLabel();
                    codeBuilder
                            .aload(0)
                            .aload(2)
                            .ldc(typeDesc)
                            .invokeinterface(mapClassDesc, "get", mapGetMethodDesc)
                            .dup()
                            .ifnonnull(valueIsNotNull);

                    try {
                        Class<?> builtinSerializerClass = builtinTypeSerializers.get(serializerField.targetType);
                        if (builtinSerializerClass != null) {
                            var serializerImplDesc = ClassDesc.of(builtinSerializerClass.getName());

                            codeBuilder
                                    .pop()
                                    .new_(serializerImplDesc)
                                    .dup()
                                    .invokespecial(serializerImplDesc, "<init>", noArgConstructorDesc)
                                    .goto_(valueIsNotNull);
                        } else {
                            var field = serializerField.targetType.getDeclaredField("NETWORK_TYPE");
                            if (field.getType() != Type.class)
                                throw new NoSuchFieldException();

                            var modifiers = field.getModifiers();
                            if (!Modifier.isPublic(modifiers) || !Modifier.isStatic(modifiers))
                                throw new NoSuchFieldException();

                            codeBuilder
                                    .pop()
                                    .getstatic(typeDesc, "NETWORK_TYPE", networkTypeClassDesc)
                                    .goto_(valueIsNotNull);
                        }
                    } catch (NoSuchFieldException e) {
                        codeBuilder
                                .pop2()
                                .new_(illegalArgExDesc)
                                .dup()
                                .ldc(String.format("I dont know how to serialize %s Use PulseServer#registerType", typeDesc.descriptorString()))
                                .invokespecial(illegalArgExDesc, "<init>", illegalArgExConstructorDesc)
                                .athrow();
                    }

                    codeBuilder
                            .labelBinding(valueIsNotNull)
                            .checkcast(networkTypeClassDesc)
                            .putfield(generatedClassDesc, serializerField.name, networkTypeClassDesc);
                }

                codeBuilder.return_();
            });
        });

//        try {
//            var path = Path.of("./src/test/java/pulse/gen/" + (proto.getName() + '$' + GENERATED_CLIENT_SUFFIX) + ".class");
//            Files.createDirectories(path.getParent());
//            Files.write(path, classBytes);
//        } catch (IOException e) {
//            throw new RuntimeException(e);
//        }

        return classBytes;
    }

    public interface Handle<T> {
        CompletableFuture<Buffer.Writable> pulse$process(int callbackId, int methodId, Buffer buffer, Executor executor);

        Class<T> pulse$prototype();
    }

    record MethodDefinition(String name, MethodTypeDesc desc, String lambdaName,
                            MethodTypeDesc lambdaMethodDesc, BiConsumer<Integer, CodeBuilder> argumentReader) {
    }

    static <T> byte[] implementServer(Class<T> proto, T instance) throws Throwable {
        var generatedClassDesc = ClassDesc.of(proto.getName() + '$' + GENERATED_SERVER_SUFFIX);

        var classBytes = ClassFile.of().build(generatedClassDesc, classBuilder -> {
            var protoClassDesc = ClassDesc.of(proto.getName());
            var instanceClassDesc = ClassDesc.of(instance.getClass().getName());

            var pulseServerClassDesc = ClassDesc.of(PulseServer.class.getName());
            var codeGenHandleClassDesc = ClassDesc.of(Handle.class.getName());

            var bufferClassDesc = ClassDesc.of(Buffer.class.getName());
            var bufferWritableClassDesc = ClassDesc.of(Buffer.Writable.class.getName());

            var executorClassDesc = ClassDesc.of(Executor.class.getName());
            var supplierClassDesc = ClassDesc.of(Supplier.class.getName());
            var completableFutureClassDesc = ClassDesc.of(CompletableFuture.class.getName());
            var completableFutureSupplyAsyncMethodTypeDesc = MethodTypeDesc.of(
                    completableFutureClassDesc,
                    supplierClassDesc, executorClassDesc
            );

            var stringBuilderClassDesc = ClassDesc.of(StringBuilder.class.getName());
            var stringBuilderAppendStringMethodDesc = MethodTypeDesc.of(stringBuilderClassDesc, ConstantDescs.CD_String);
            var stringBuilderAppendIntMethodDesc = MethodTypeDesc.of(stringBuilderClassDesc, ConstantDescs.CD_int);
            var stringBuilderToStringMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_String);

            var processMethodSignatureAttribute = SignatureAttribute.of(MethodSignature.parseFrom(
                    "(IILpulse/network/Buffer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletableFuture<Lpulse/network/Buffer$Writable;>;")
            );

            DirectMethodHandleDesc bootstrapMethodDesc = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,
                    ClassDesc.of("java.lang.invoke.LambdaMetafactory"),
                    "metafactory",
                    MethodTypeDesc.ofDescriptor("(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;"
                            + "Ljava/lang/invoke/MethodType;"
                            + "Ljava/lang/invoke/MethodType;"
                            + "Ljava/lang/invoke/MethodHandle;"
                            + "Ljava/lang/invoke/MethodType;"
                            + ")Ljava/lang/invoke/CallSite;"));

            var bufferReadByteMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_byte);
            var bufferWriteByteMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_byte);
            var bufferReadBooleanMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_boolean);
            var bufferWriteBooleanMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_boolean);
            var bufferReadCharMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_char);
            var bufferWriteCharMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_char);
            var bufferReadShortMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_short);
            var bufferWriteShortMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_short);
            var bufferReadIntMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_int);
            var bufferWriteIntMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_int);
            var bufferReadLongMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_long);
            var bufferWriteLongMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_long);
            var bufferReadFloatMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_float);
            var bufferWriteFloatMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_float);
            var bufferReadDoubleMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_double);
            var bufferWriteDoubleMethodDesc = MethodTypeDesc
                    .of(ConstantDescs.CD_void, ConstantDescs.CD_double);

            var mapClassDesc = ClassDesc.of(Map.class.getName());
            var mapGetMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_Object, ConstantDescs.CD_Object);

            var networkTypeClassDesc = ClassDesc.of(Type.class.getName());
            var networkTypeClassDescStr = networkTypeClassDesc.descriptorString();
            var networkTypeClassDescStrForSignature = networkTypeClassDescStr.substring(0, networkTypeClassDescStr.length() - 1);
            var networkTypeReadMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_Object, bufferClassDesc);
            var networkTypeWriteMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, bufferClassDesc, ConstantDescs.CD_Object);

            var illegalArgExDesc = ClassDesc.of(IllegalArgumentException.class.getName());
            var illegalArgExConstructorDesc = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String);

            var noArgConstructorDesc = MethodTypeDesc.of(ConstantDescs.CD_void);

            Map<Class<?>, Class<?>> builtinTypeSerializers = Map.ofEntries(
                    entry(Byte.class, BuiltinType.ByteType.class),
                    entry(byte[].class, BuiltinType.ByteArrayType.class),
                    entry(Boolean.class, BuiltinType.BooleanType.class),
                    entry(boolean[].class, BuiltinType.BooleanArrayType.class),
                    entry(Character.class, BuiltinType.CharacterType.class),
                    entry(char[].class, BuiltinType.CharArrayType.class),
                    entry(Short.class, BuiltinType.ShortType.class),
                    entry(short[].class, BuiltinType.ShortArrayType.class),
                    entry(Integer.class, BuiltinType.IntegerType.class),
                    entry(int[].class, BuiltinType.IntArrayType.class),
                    entry(Long.class, BuiltinType.LongType.class),
                    entry(long[].class, BuiltinType.LongArrayType.class),
                    entry(Float.class, BuiltinType.FloatType.class),
                    entry(float[].class, BuiltinType.FloatArrayType.class),
                    entry(Double.class, BuiltinType.DoubleType.class),
                    entry(double[].class, BuiltinType.DoubleArrayType.class),
                    entry(String.class, BuiltinType.StringUtf8Type.class)
            );

            classBuilder
                    .with(SourceFileAttribute.of(classBuilder.constantPool().utf8Entry(("Generated by Pulse"))))
                    .withFlags(ClassFile.ACC_PUBLIC | ClassFile.ACC_FINAL)
                    .withInterfaceSymbols(protoClassDesc, codeGenHandleClassDesc);

            classBuilder.withField("server", pulseServerClassDesc,
                    fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL));
            classBuilder.withField("instance", instanceClassDesc,
                    fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL));

            var nextLambdaId = 0;

            var declaredMethods = proto.getDeclaredMethods();
            Arrays.sort(declaredMethods, Comparator.comparing(Method::getName));

            var methodDefs = new ArrayList<MethodDefinition>(declaredMethods.length);

            var nextFieldId = 0;
            var classDescToSerializerFieldMap = new LinkedHashMap<ClassDesc, SerializerField>();

            for (Method declaredMethod : declaredMethods) {
                int declaredModifiers = declaredMethod.getModifiers();
                if (Modifier.isFinal(declaredModifiers) || Modifier.isStatic(declaredModifiers)) continue;

                var returnType = declaredMethod.getReturnType();
                var returnTypeDescStr = returnType.descriptorString();
                var returnTypeClassDesc = ClassDesc.ofDescriptor(returnTypeDescStr);

                var isReturnPrimitive = returnTypeClassDesc.isPrimitive();
                var isReturnVoid = returnTypeClassDesc == ConstantDescs.CD_void;

                if (!isReturnPrimitive) {
                    var typeName = returnTypeClassDesc.displayName().replace("[]", "Array");
                    var fieldName = typeName + '$' + "ser" + nextFieldId++;
                    classDescToSerializerFieldMap.computeIfAbsent(returnTypeClassDesc, _ -> {
                        var signature = SignatureAttribute.of(Signature.parseFrom(
                                String.format("%s<%s>;", networkTypeClassDescStrForSignature, returnTypeDescStr)
                        ));
                        classBuilder.withField(fieldName, networkTypeClassDesc,
                                fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL).with(signature));
                        return new SerializerField(fieldName, returnType);
                    });
                }

                List<ClassDesc> parametersClassDescs = new ArrayList<>();
                for (Parameter parameter : declaredMethod.getParameters()) {
                    var parameterType = parameter.getType();
                    ClassDesc parameterClassDesc = ClassDesc.ofDescriptor(parameterType.descriptorString());
                    parametersClassDescs.add(parameterClassDesc);

                    if (!parameterClassDesc.isPrimitive()) {
                        var typeName = parameterClassDesc.displayName().replace("[]", "Array");
                        var fieldName = typeName + '$' + "ser" + nextFieldId++;
                        classDescToSerializerFieldMap.computeIfAbsent(parameterClassDesc, _ -> {
                            var signature = SignatureAttribute.of(Signature.parseFrom(
                                    String.format("%s<%s>;", networkTypeClassDescStrForSignature, parameterClassDesc.descriptorString())
                            ));
                            classBuilder.withField(fieldName, networkTypeClassDesc,
                                    fieldBuilder -> fieldBuilder.withFlags(ClassFile.ACC_PRIVATE | ClassFile.ACC_FINAL).with(signature));
                            return new SerializerField(fieldName, parameterType);
                        });
                    }
                }

                int modifiers = (declaredMethod.getModifiers() & ~Modifier.ABSTRACT) | Modifier.PUBLIC | Modifier.FINAL;
                var declaredMethodDesc = MethodTypeDesc.of(returnTypeClassDesc, parametersClassDescs);

                classBuilder.withMethodBody(declaredMethod.getName(), declaredMethodDesc, modifiers, codeBuilder -> {
                    codeBuilder
                            .aload(0)
                            .getfield(generatedClassDesc, "instance", instanceClassDesc);

                    int slot = 1; // 0 = this
                    for (var parameterClassDesc : parametersClassDescs) {
                        switch (parameterClassDesc.descriptorString()) {
                            case "I", "B", "S", "C", "Z" -> {
                                codeBuilder.iload(slot);
                                slot += 1;
                            }
                            case "F" -> {
                                codeBuilder.fload(slot);
                                slot += 1;
                            }

                            case "J" -> {
                                codeBuilder.lload(slot);
                                slot += 2;
                            }
                            case "D" -> {
                                codeBuilder.dload(slot);
                                slot += 2;
                            }

                            default -> {
                                codeBuilder.aload(slot);
                                slot += 1;
                            }
                        }
                    }

                    codeBuilder.invokevirtual(instanceClassDesc, declaredMethod.getName(), declaredMethodDesc);

                    switch (returnTypeClassDesc.descriptorString()) {
                        case "I", "Z", "B", "C", "S" -> codeBuilder.ireturn();
                        case "J" -> codeBuilder.lreturn();
                        case "F" -> codeBuilder.freturn();
                        case "D" -> codeBuilder.dreturn();
                        case "V" -> codeBuilder.return_();
                        default -> codeBuilder.areturn();
                    }
                });

                var lambdaName = "lambda" + '$' + declaredMethod.getName() + '$' + nextLambdaId++;
                var lambdaMethodDesc = MethodTypeDesc.of(bufferWritableClassDesc, parametersClassDescs);

                var serializeLambdaName = "lambda" + '$' + declaredMethod.getName() + '$' + "ser" + nextLambdaId++;
                if (!isReturnVoid) {
                    final MethodTypeDesc serializeLambdaMethodDesc;
                    if (isReturnPrimitive) {
                        serializeLambdaMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, returnTypeClassDesc, bufferClassDesc);
                    } else {
                        serializeLambdaMethodDesc = MethodTypeDesc.of(ConstantDescs.CD_void, generatedClassDesc, returnTypeClassDesc, bufferClassDesc);
                    }

                    classBuilder.withMethodBody(serializeLambdaName, serializeLambdaMethodDesc,
                            ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC,
                            codeBuilder -> {
                                if (!isReturnPrimitive) {
                                    var serializerField = classDescToSerializerFieldMap.get(returnTypeClassDesc);
                                    assert serializerField != null;

                                    codeBuilder
                                            .aload(0)
                                            .getfield(generatedClassDesc, serializerField.name, networkTypeClassDesc)
                                            .aload(2)
                                            .aload(1)
                                            .invokeinterface(networkTypeClassDesc, "write", networkTypeWriteMethodDesc);
                                } else {
                                    switch (returnTypeClassDesc.descriptorString()) {
                                        case "I", "B", "S", "C", "Z" -> codeBuilder.aload(1).iload(0);
                                        case "F" -> codeBuilder.aload(1).fload(0);
                                        case "J" -> codeBuilder.aload(2).lload(0);
                                        case "D" -> codeBuilder.aload(2).dload(0);
                                        // default -> codeBuilder.aload(0);
                                    }

                                    switch (returnTypeDescStr) {
                                        case "B" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeByte", bufferWriteByteMethodDesc);
                                        case "Z" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeBoolean", bufferWriteBooleanMethodDesc);
                                        case "C" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeChar", bufferWriteCharMethodDesc);
                                        case "S" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeShort", bufferWriteShortMethodDesc);
                                        case "I" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeInt", bufferWriteIntMethodDesc);
                                        case "J" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeLong", bufferWriteLongMethodDesc);
                                        case "F" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeFloat", bufferWriteFloatMethodDesc);
                                        case "D" ->
                                                codeBuilder.invokevirtual(bufferClassDesc, "writeDouble", bufferWriteDoubleMethodDesc);
                                    }
                                }

                                codeBuilder.return_();
                            }
                    );
                }

                classBuilder.withMethodBody(lambdaName, lambdaMethodDesc,
                        ClassFile.ACC_PRIVATE | ClassFile.ACC_SYNTHETIC,
                        codeBuilder -> {
                            codeBuilder.aload(0);

                            int slot = 1; // 0 = this
                            for (var parameterClassDesc : parametersClassDescs) {
                                switch (parameterClassDesc.descriptorString()) {
                                    case "I", "Z", "B", "C", "S" -> {
                                        codeBuilder.iload(slot);
                                        slot += 1;
                                    }
                                    case "F" -> {
                                        codeBuilder.fload(slot);
                                        slot += 1;
                                    }

                                    case "J" -> {
                                        codeBuilder.lload(slot);
                                        slot += 2;
                                    }
                                    case "D" -> {
                                        codeBuilder.dload(slot);
                                        slot += 2;
                                    }

                                    default -> {
                                        codeBuilder.aload(slot);
                                        slot += 1;
                                    }
                                }
                            }

                            codeBuilder.invokevirtual(generatedClassDesc, declaredMethod.getName(), declaredMethodDesc);

                            if (isReturnVoid) {
                                codeBuilder
                                        .getstatic(bufferWritableClassDesc, "DUMMY", bufferWritableClassDesc)
                                        .areturn();
                                return;
                            }

                            int resultSlot = slot;
                            switch (returnTypeDescStr) {
                                case "I", "Z", "B", "C", "S" -> codeBuilder.istore(resultSlot);
                                case "J" -> codeBuilder.lstore(resultSlot);
                                case "F" -> codeBuilder.fstore(resultSlot);
                                case "D" -> codeBuilder.dstore(resultSlot);

                                default -> codeBuilder.astore(resultSlot);
                            }

                            final MethodTypeDesc invocationType;
                            final MethodHandleDesc implMethodHandleDesc;

                            if (isReturnPrimitive) {
                                invocationType = MethodTypeDesc.of(bufferWritableClassDesc, returnTypeClassDesc);
                                implMethodHandleDesc = MethodHandleDesc.ofMethod(
                                        DirectMethodHandleDesc.Kind.STATIC,
                                        generatedClassDesc,
                                        serializeLambdaName,
                                        MethodTypeDesc.of(ConstantDescs.CD_void, returnTypeClassDesc, bufferClassDesc)
                                );
                            } else {
                                invocationType = MethodTypeDesc.of(bufferWritableClassDesc, generatedClassDesc, returnTypeClassDesc);
                                implMethodHandleDesc = MethodHandleDesc.ofMethod(
                                        DirectMethodHandleDesc.Kind.STATIC,
                                        generatedClassDesc,
                                        serializeLambdaName,
                                        MethodTypeDesc.of(ConstantDescs.CD_void, generatedClassDesc, returnTypeClassDesc, bufferClassDesc)
                                );
                                codeBuilder.aload(0);
                            }

                            switch (returnTypeDescStr) {
                                case "I", "Z", "B", "C", "S" -> codeBuilder.iload(resultSlot);
                                case "J" -> codeBuilder.lload(resultSlot);
                                case "F" -> codeBuilder.fload(resultSlot);
                                case "D" -> codeBuilder.dload(resultSlot);
                                default -> codeBuilder.aload(resultSlot);
                            }

                            DynamicCallSiteDesc callSiteDesc = DynamicCallSiteDesc.of(
                                    bootstrapMethodDesc,
                                    "writeSelfInto",
                                    invocationType,
                                    MethodTypeDesc.of(ConstantDescs.CD_void, bufferClassDesc),
                                    implMethodHandleDesc,
                                    MethodTypeDesc.of(ConstantDescs.CD_void, bufferClassDesc)
                            );

                            codeBuilder
                                    .invokedynamic(callSiteDesc)
                                    .areturn();
                        });

                BiConsumer<Integer, CodeBuilder> argumentReader = (offset, codeBuilder) -> {
                    int slot = offset;
                    for (var parameterClassDesc : parametersClassDescs) {
                        switch (parameterClassDesc.descriptorString()) {
                            case "B" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readByte", bufferReadByteMethodDesc)
                                        .istore(slot);
                                slot += 1;
                            }
                            case "Z" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readBoolean", bufferReadBooleanMethodDesc)
                                        .istore(slot);
                                slot += 1;
                            }

                            case "C" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readChar", bufferReadCharMethodDesc)
                                        .istore(slot);
                                slot += 1;
                            }
                            case "S" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readShort", bufferReadShortMethodDesc)
                                        .istore(slot);
                                slot += 1;
                            }

                            case "I" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readInt", bufferReadIntMethodDesc)
                                        .istore(slot);
                                slot += 1;
                            }
                            case "F" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readFloat", bufferReadFloatMethodDesc)
                                        .fstore(slot);
                                slot += 1;
                            }

                            case "J" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readLong", bufferReadLongMethodDesc)
                                        .lstore(slot);
                                slot += 2;
                            }
                            case "D" -> {
                                codeBuilder
                                        .aload(3)
                                        .invokevirtual(bufferClassDesc, "readDouble", bufferReadDoubleMethodDesc)
                                        .dstore(slot);
                                slot += 2;
                            }

                            default -> {
                                var serializerField = classDescToSerializerFieldMap.get(parameterClassDesc);
                                assert serializerField != null;

                                codeBuilder
                                        .aload(0)
                                        .getfield(generatedClassDesc, serializerField.name, networkTypeClassDesc)
                                        .aload(3)
                                        .invokeinterface(networkTypeClassDesc, "read", networkTypeReadMethodDesc)
                                        .checkcast(parameterClassDesc)
                                        .astore(slot);
                                slot += 1;
                            }
                        }
                    }

                    codeBuilder.aload(0);

                    slot = offset;
                    for (var parameterClassDesc : parametersClassDescs) {
                        switch (parameterClassDesc.descriptorString()) {
                            case "I", "Z", "B", "C", "S" -> {
                                codeBuilder.iload(slot);
                                slot += 1;
                            }
                            case "F" -> {
                                codeBuilder.fload(slot);
                                slot += 1;
                            }

                            case "J" -> {
                                codeBuilder.lload(slot);
                                slot += 2;
                            }
                            case "D" -> {
                                codeBuilder.dload(slot);
                                slot += 2;
                            }

                            default -> {
                                codeBuilder.aload(slot);
                                slot += 1;
                            }
                        }
                    }
                };

                var methodDef = new MethodDefinition(
                        declaredMethod.getName(), declaredMethodDesc, lambdaName, lambdaMethodDesc, argumentReader
                );
                methodDefs.add(methodDef);
            }

            classBuilder.withMethod("pulse$process",
                    MethodTypeDesc.ofDescriptor("(IILpulse/network/Buffer;Ljava/util/concurrent/Executor;)Ljava/util/concurrent/CompletableFuture;"),
                    ClassFile.ACC_PUBLIC,
                    methodBuilder -> {
                        methodBuilder.with(processMethodSignatureAttribute);

                        methodBuilder.withCode(codeBuilder -> {
                            codeBuilder.iload(2);

                            var defaultLabel = codeBuilder.newLabel();
                            var labels = new ArrayList<Label>(methodDefs.size());

                            for (int i = 0; i < methodDefs.size(); i++) {
                                labels.add(codeBuilder.newLabel());
                            }

                            var switchCaseList = new ArrayList<SwitchCase>();
                            for (int i = 0; i < labels.size(); i++) {
                                switchCaseList.add(SwitchCase.of(i, labels.get(i)));
                            }

                            codeBuilder.lookupswitch(defaultLabel, switchCaseList);

                            for (int i = 0; i < methodDefs.size(); i++) {
                                codeBuilder.labelBinding(labels.get(i));

                                MethodDefinition methodDef = methodDefs.get(i);

                                var lambdaParamList = new ArrayList<ClassDesc>();
                                lambdaParamList.add(generatedClassDesc);
                                lambdaParamList.addAll(methodDef.lambdaMethodDesc.parameterList());

                                DynamicCallSiteDesc callSiteDesc = DynamicCallSiteDesc.of(
                                        bootstrapMethodDesc,
                                        "get",
                                        MethodTypeDesc.of(supplierClassDesc, lambdaParamList),
                                        MethodTypeDesc.of(ConstantDescs.CD_Object),
                                        MethodHandleDesc.ofMethod(
                                                DirectMethodHandleDesc.Kind.VIRTUAL,
                                                generatedClassDesc,
                                                methodDef.lambdaName,
                                                MethodTypeDesc.of(
                                                        bufferWritableClassDesc,
                                                        methodDef.lambdaMethodDesc.parameterList()
                                                )
                                        ),
                                        MethodTypeDesc.of(bufferWritableClassDesc)
                                );

                                methodDef.argumentReader.accept(5, codeBuilder);
                                codeBuilder.invokedynamic(callSiteDesc);

                                codeBuilder.aload(4);
                                codeBuilder.invokestatic(
                                        completableFutureClassDesc,
                                        "supplyAsync",
                                        completableFutureSupplyAsyncMethodTypeDesc
                                );

                                codeBuilder.areturn();
                            }

                            codeBuilder.labelBinding(defaultLabel)
                                    .new_(illegalArgExDesc)
                                    .dup()
                                    .new_(stringBuilderClassDesc)
                                    .dup()
                                    .invokespecial(stringBuilderClassDesc, "<init>", noArgConstructorDesc)
                                    .loadConstant("Unknown method: ")
                                    .invokevirtual(stringBuilderClassDesc, "append", stringBuilderAppendStringMethodDesc)
                                    .iload(2)
                                    .invokevirtual(stringBuilderClassDesc, "append", stringBuilderAppendIntMethodDesc)
                                    .invokevirtual(stringBuilderClassDesc, "toString", stringBuilderToStringMethodDesc)
                                    .invokespecial(illegalArgExDesc, "<init>", illegalArgExConstructorDesc)
                                    .athrow();
                        });
                    }
            );

            classBuilder.withMethodBody("pulse$prototype", MethodTypeDesc.ofDescriptor("()Ljava/lang/Class;"),
                    ClassFile.ACC_PUBLIC, codeBuilder -> codeBuilder.ldc(protoClassDesc).areturn());

            var constructorDesc = MethodTypeDesc.of(ConstantDescs.CD_void, pulseServerClassDesc, instanceClassDesc, mapClassDesc);
            classBuilder.withMethodBody("<init>", constructorDesc, ClassFile.ACC_PUBLIC, codeBuilder -> {
                codeBuilder
                        .aload(0)
                        .invokespecial(ConstantDescs.CD_Object, "<init>", noArgConstructorDesc)
                        .aload(0)
                        .aload(1)
                        .putfield(generatedClassDesc, "server", pulseServerClassDesc)
                        .aload(0)
                        .aload(2)
                        .putfield(generatedClassDesc, "instance", instanceClassDesc);

                for (var entry : classDescToSerializerFieldMap.entrySet()) {
                    var typeDesc = entry.getKey();
                    var serializerField = entry.getValue();

                    var valueIsNotNull = codeBuilder.newLabel();
                    codeBuilder
                            .aload(0)
                            .aload(3)
                            .ldc(typeDesc)
                            .invokeinterface(mapClassDesc, "get", mapGetMethodDesc)
                            .dup()
                            .ifnonnull(valueIsNotNull);

                    try {
                        Class<?> builtinSerializerClass = builtinTypeSerializers.get(serializerField.targetType);
                        if (builtinSerializerClass != null) {
                            var serializerImplDesc = ClassDesc.of(builtinSerializerClass.getName());

                            codeBuilder
                                    .pop()
                                    .new_(serializerImplDesc)
                                    .dup()
                                    .invokespecial(serializerImplDesc, "<init>", noArgConstructorDesc)
                                    .goto_(valueIsNotNull);
                        } else {
                            var field = serializerField.targetType.getDeclaredField("NETWORK_TYPE");
                            if (field.getType() != Type.class)
                                throw new NoSuchFieldException();

                            var modifiers = field.getModifiers();
                            if (!Modifier.isPublic(modifiers) || !Modifier.isStatic(modifiers))
                                throw new NoSuchFieldException();

                            codeBuilder
                                    .pop()
                                    .getstatic(typeDesc, "NETWORK_TYPE", networkTypeClassDesc)
                                    .goto_(valueIsNotNull);
                        }
                    } catch (NoSuchFieldException e) {
                        codeBuilder
                                .pop2()
                                .new_(illegalArgExDesc)
                                .dup()
                                .ldc(String.format("I dont know how to serialize %s Use PulseServer#registerType", typeDesc.descriptorString()))
                                .invokespecial(illegalArgExDesc, "<init>", illegalArgExConstructorDesc)
                                .athrow();
                    }

                    codeBuilder
                            .labelBinding(valueIsNotNull)
                            .checkcast(networkTypeClassDesc)
                            .putfield(generatedClassDesc, serializerField.name, networkTypeClassDesc);
                }

                codeBuilder.return_();
            });
        });

//        try {
//            var path = Path.of("./src/test/java/pulse/gen/" + (proto.getName() + '$' + GENERATED_SERVER_SUFFIX) + ".class");
//            Files.createDirectories(path.getParent());
//            Files.write(path, classBytes);
//        } catch (IOException e) {
//            throw new RuntimeException(e);
//        }

        return classBytes;
    }
}
